package veild

import (
	"reflect"
	"testing"
)

func Test_NewRR(t *testing.T) {
	packet := []byte{
		0x06, 0x61, 0x6d, 0x61, 0x7a, 0x6f, 0x6e, 0x02,
		0x63, 0x6f, 0x02, 0x75, 0x6b, 0x00, 0x00, 0x41,
		0x00, 0x01,
	}
	if _, err := NewRR(packet); err != nil {
		t.Log(err)
	}

}

func Test_sliceNameType(t *testing.T) {
	packet := []byte{
		0x06, 0x61, 0x6d, 0x61, 0x7a, 0x6f, 0x6e, 0x02,
		0x63, 0x6f, 0x02, 0x75, 0x6b, 0x00, 0x00, 0x01,
		0x00, 0x01,
	}
	shouldBe := []byte{
		0x06, 0x61, 0x6d, 0x61, 0x7a, 0x6f, 0x6e, 0x02,
		0x63, 0x6f, 0x02, 0x75, 0x6b, 0x00, 0x00, 0x01,
	}
	nameType, _ := sliceNameType(packet)
	if !reflect.DeepEqual(nameType, shouldBe) {
		t.Fail()
	}

	failureCase := []byte{0x01}

	failedNameType, _ := sliceNameType(failureCase)
	if !reflect.DeepEqual(failedNameType, []byte{}) {
		t.Fail()
	}
}

func Test_parseDomainName(t *testing.T) {
	packetBytes := []byte{
		0x0d, 0x6a, 0x61, 0x6d, 0x65, 0x73, 0x64, 0x75,
		0x6e, 0x63, 0x6f, 0x6d, 0x62, 0x65, 0x03, 0x63,
		0x6f, 0x6d, 0x00,
	}
	if !reflect.DeepEqual(parseDomainName(packetBytes), "jamesduncombe.com") {
		t.Fail()
	}
}

func Benchmark_parseDomainName(b *testing.B) {
	packetBytes := []byte{
		0x0d, 0x6a, 0x61, 0x6d, 0x65, 0x73, 0x64, 0x75,
		0x6e, 0x63, 0x6f, 0x6d, 0x62, 0x65, 0x03, 0x63,
		0x6f, 0x6d, 0x00,
	}
	for n := 0; n < b.N; n++ {
		parseDomainName(packetBytes)
	}
}
