package veild

import (
	"reflect"
	"testing"
)

func Test_NewRR(t *testing.T) {
	// Query for protonmail.com A record.
	packet := []byte{
		0xa, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x6e, 0x6d,
		0x61, 0x69, 0x6c, 0x3, 0x63, 0x6f, 0x6d, 0x0,
		0x00, 0x01,
	}
	if _, err := NewRR(packet); err != nil {
		t.Log(err)
	}
}

func Test_sliceNameType(t *testing.T) {
	packet := []byte{
		0xa, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x6e, 0x6d,
		0x61, 0x69, 0x6c, 0x3, 0x63, 0x6f, 0x6d, 0x0,
		0x00, 0x01, 0x1, 0x3, 0x5,
	}
	shouldBe := []byte{
		0xa, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x6e, 0x6d,
		0x61, 0x69, 0x6c, 0x3, 0x63, 0x6f, 0x6d, 0x0,
		0x00, 0x01,
	}
	nameType, _ := sliceNameType(packet)
	if !reflect.DeepEqual(nameType, shouldBe) {
		t.Errorf("wanted %s, got %s", shouldBe, nameType)
	}

	failureCase := []byte{0x01}

	_, err := sliceNameType(failureCase)
	if err != ErrInvalidDnsPacket {
		t.Error("expected error ", err)
	}

}

func Test_parseDomainName(t *testing.T) {
	packetBytes := []byte{
		0xa, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x6e, 0x6d,
		0x61, 0x69, 0x6c, 0x3, 0x63, 0x6f, 0x6d, 0x0,
	}

	if !reflect.DeepEqual(parseDomainName(packetBytes), "protonmail.com") {
		t.Fail()
	}
}

func Benchmark_parseDomainName(b *testing.B) {
	packetBytes := []byte{
		0xa, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x6e, 0x6d,
		0x61, 0x69, 0x6c, 0x3, 0x63, 0x6f, 0x6d, 0x0,
	}

	for n := 0; n < b.N; n++ {
		parseDomainName(packetBytes)
	}
}
